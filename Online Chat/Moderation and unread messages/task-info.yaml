type: edu
files:
- name: src/chat/Main.java
  visible: true
  text: |
    package chat;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
  learner_created: false
- name: test/Tests.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.input.DynamicTestingMethod;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;
    import org.junit.AfterClass;
    import org.junit.BeforeClass;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.Arrays;

    import static org.hyperskill.hstest.common.Utils.sleep;

    public class Tests extends StageTest<String> {
        private final int executePause = 50;
        private static final String userDBFileName = "usersdb.txt";
        private static final String tempUserDBFileName = "tempusersdb.txt";
        private static final String messageDBFileName = "messagedb.txt";
        private static final String tempMessageDBFileName = "tempmessagedb.txt";

        @DynamicTestingMethod
        CheckResult test1_Stage5() {
            final TestedProgram server = new TestedProgram("chat.server");
            final TestedProgram client1 = new TestedProgram("chat.client");
            final TestedProgram client2 = new TestedProgram("chat.client");
            final TestedProgram client3 = new TestedProgram("chat.client");
            client1.setReturnOutputAfterExecution(false);
            client2.setReturnOutputAfterExecution(false);
            client3.setReturnOutputAfterExecution(false);

            server.startInBackground();
            sleep(executePause);
            client1.start();
            sleep(executePause);
            client2.start();
            sleep(executePause);
            client3.start();
            sleep(executePause);
            client3.getOutput();
            client2.getOutput();

            final String client1Start = client1.getOutput().trim();
            if (!client1Start.contains("Server: authorize or register")) {
                return CheckResult.wrong(
                        "Can't find \"Server: authorize or register\" message");
            }

            client1.execute("bla bla bla");
            sleep(executePause);
            final String client1Answer1 = client1.getOutput().trim();
            if (!client1Answer1.contains("Server: you are not in the chat!")) {
                return CheckResult.wrong(
                        "Can't find  \"Server: you are not in the chat!\" " +
                                "message after trying to send a message before /auth or /register commands");
            }

            client1.execute("/auth asdasd asdasd");
            sleep(executePause);
            final String client1Answer2 = client1.getOutput().trim();
            if (!client1Answer2.contains("Server: incorrect login!")) {
                return CheckResult.wrong(
                        "Can't find \"Server: incorrect login!\" " +
                                "message after inputting wrong login and password");
            }

            client2.execute("/registration first pass");
            sleep(executePause);
            final String client2Answer1 = client2.getOutput().trim();
            if (!client2Answer1.contains("Server: the password is too short!")) {
                return CheckResult.wrong(
                        "Can't find \"Server: the password is too short!\" " +
                                "message after trying to register with short password");
            }

            client2.execute("/registration first 12345678");
            sleep(executePause);
            final String client2Answer2 = client2.getOutput().trim();
            if (!client2Answer2.contains("Server: you are registered successfully!")) {
                return CheckResult.wrong(
                        "Can't find \"Server: you are registered successfully!\" " +
                                "message after successful authentication");
            }

            client2.execute("before choosing an addressee");
            sleep(executePause);
            final String client2Answer3 = client2.getOutput().trim();
            if (!client2Answer3.contains("Server: use /list command to choose a user to text!")) {
                return CheckResult.wrong(
                        "Can't find \"Server: use /list command to choose a user to text!\" " +
                                "message before choosing an addressee");
            }

            client2.execute("/list");
            sleep(executePause);
            final String client2Answer4 = client2.getOutput().trim();
            if (!client2Answer4.contains("Server: no one online")) {
                return CheckResult.wrong(
                        "Can't find \"Server: no one online\" message if there are no users online");
            }

            client2.execute("/exit");
            sleep(executePause);
            if (!client2.isFinished()) {
                return CheckResult.wrong("Client should be shut down, after the \"/exit\" command");
            }

            client1.execute("/auth first paasf");
            sleep(executePause);
            final String client1Answer3 = client1.getOutput().trim();
            if (!client1Answer3.contains("Server: incorrect password!")) {
                return CheckResult.wrong(
                        "Can't find \"Server: incorrect password!\" " +
                                "message after inputting a wrong password");
            }

            client1.execute("/auth first 12345678");
            sleep(executePause);
            final String client1Answer4 = client1.getOutput().trim();
            if (!client1Answer4.contains("Server: you are authorized successfully!")) {
                return CheckResult.wrong("Can't find \"Server: you are authorized " +
                        "successfully!\" message after successful authentication");
            }

            client3.execute("/registration first 12345678");
            sleep(executePause);
            final String client3Answer1 = client3.getOutput().trim();
            if (!client3Answer1.contains("Server: this login is already taken! Choose another one.")) {
                return CheckResult.wrong(
                        "Can't find \"Server: this login is already taken! Choose another one.\" " +
                                "message from a client that is trying to register with a login which is already taken");
            }

            client3.execute("/registration second 12345678");
            sleep(executePause);
            final String client3Answer2 = client3.getOutput().trim();
            if (!client3Answer2.contains("Server: you are registered successfully!")) {
                return CheckResult.wrong("Can't get the \"Server: you are registered " +
                        "successfully!\" message after successful authentication");
            }

            client1.execute("/list");
            sleep(executePause);
            final String client1Answer5 = client1.getOutput().trim();
            if (client1Answer5.contains("first")) {
                return CheckResult.wrong("The list of online users contains the client's name, but shouldn't");
            }

            if (!client1Answer5.contains("Server: online: second")) {
                return CheckResult.wrong("A client receive a wrong list of online users. " +
                        "Should be \"Server: online: second\"");
            }

            client1.execute("/chat blabla");
            sleep(executePause);
            final String client1Answer6 = client1.getOutput().trim();
            if (!client1Answer6.contains("Server: the user is not online!")) {
                return CheckResult.wrong("Can't find \"Server: the user is not online!\"" +
                        "after trying to chat using wrong username");
            }

            client1.execute("blabla");
            sleep(executePause);
            final String client1Answer7 = client1.getOutput().trim();
            if (!client1Answer7.contains("Server: use /list command to choose a user to text!")) {
                return CheckResult.wrong("Can't find \"Server: use /list command to " +
                        "choose a user to text!\" after trying to chat without choosing a user");
            }

            client1.execute("/chat second");
            sleep(executePause);

            client1.execute("test");
            sleep(executePause);
            final String client3Answer3 = client3.getOutput().trim();
            if (!client3Answer3.isEmpty()) {
                return CheckResult.wrong("Client \"second\" received a message \"" + client3Answer3 + "\" " +
                        "but shouldn't receive anything");
            }

            client3.execute("/chat first");
            sleep(executePause);
            final String client3Answer4 = client3.getOutput().trim();
            if (!client3Answer4.contains("(new) first: test")) {
                return CheckResult.wrong("Client \"second\" didn't receive " +
                        "a message in a format \"(new) userName: message\". Should be \"(new) first: test\".");
            }

            for (String s : Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
                client1.execute(s);
                sleep(executePause);
            }
            client3.execute("10");
            sleep(executePause);

            final String client1Answer8 = client1.getOutput().trim();
            if (client1Answer8.contains("new")) {
                return CheckResult.wrong("Client \"first\" should not mark " +
                        "it's messages with \"new\" since he's chatting with the \"second\" right now.");
            }
            if (!client1Answer8.equals(
                    "first: test\n" +
                            "first: 1\n" +
                            "first: 2\n" +
                            "first: 3\n" +
                            "first: 4\n" +
                            "first: 5\n" +
                            "first: 6\n" +
                            "first: 7\n" +
                            "first: 8\n" +
                            "first: 9\n" +
                            "second: 10")) {
                return CheckResult.wrong("Client \"first\" output wrong messages.");
            }

            final String client3Answer5 = client3.getOutput().trim();
            if (client3Answer5.contains("new")) {
                return CheckResult.wrong("Client \"second\" should not mark " +
                        "it's messages with \"new\" since he's chatting with the \"first\" right now.");
            }
            if (!client3Answer5.equals(
                    "first: 1\n" +
                            "first: 2\n" +
                            "first: 3\n" +
                            "first: 4\n" +
                            "first: 5\n" +
                            "first: 6\n" +
                            "first: 7\n" +
                            "first: 8\n" +
                            "first: 9\n" +
                            "second: 10")) {
                return CheckResult.wrong("Client \"second\" output wrong messages.");
            }

            client1.execute("/exit");
            sleep(executePause);
            client3.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @DynamicTestingMethod
        CheckResult test2_lastMessagesExtendedEdition() {
            final TestedProgram server2 = new TestedProgram("chat.server");
            final TestedProgram client1 = new TestedProgram("chat.client");
            final TestedProgram client2 = new TestedProgram("chat.client");
            final TestedProgram admin = new TestedProgram("chat.client");
            client1.setReturnOutputAfterExecution(false);
            client2.setReturnOutputAfterExecution(false);
            admin.setReturnOutputAfterExecution(false);
            server2.startInBackground();
            sleep(executePause);
            client1.start();
            sleep(executePause);
            client2.start();
            sleep(executePause);
            admin.start();
            sleep(executePause);
            client1.getOutput();
            client2.getOutput();
            admin.getOutput();

            client1.execute("/auth first 12345678");
            sleep(executePause);
            final String clientAnswer1 = client1.getOutput().trim();
            if (!clientAnswer1.contains("Server: you are authorized successfully!")) {
                return CheckResult.wrong("A registered client can't be authenticated after rebooting a server");
            }

            client2.execute("/auth second 12345678");
            sleep(executePause);
            client2.execute("/chat first");
            client2.execute("unread");
            sleep(executePause);

            client1.execute("/chat second");
            sleep(executePause);

            final String client1Answer2 = client1.getOutput().trim();
            if (!client1Answer2.equals(
                    "first: 1\n" +
                            "first: 2\n" +
                            "first: 3\n" +
                            "first: 4\n" +
                            "first: 5\n" +
                            "first: 6\n" +
                            "first: 7\n" +
                            "first: 8\n" +
                            "first: 9\n" +
                            "second: 10\n" +
                            "(new) second: unread")) {
                return CheckResult.wrong("A client should receive ALL unread messages marked with \"new\" and " +
                        "10 additional last messages from the end of the conversation");
            }

            client1.execute("/exit");
            sleep(executePause);
            client2.execute("/exit");
            sleep(executePause);
            admin.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @DynamicTestingMethod
        CheckResult test3_kickAndGrant() {
            final TestedProgram server = new TestedProgram("chat.server");
            final TestedProgram client1 = new TestedProgram("chat.client");
            final TestedProgram client2 = new TestedProgram("chat.client");
            final TestedProgram client3 = new TestedProgram("chat.client");
            final TestedProgram admin = new TestedProgram("chat.client");
            client1.setReturnOutputAfterExecution(false);
            client2.setReturnOutputAfterExecution(false);
            client3.setReturnOutputAfterExecution(false);
            admin.setReturnOutputAfterExecution(false);
            server.startInBackground();
            sleep(executePause);
            client1.start();
            sleep(executePause);
            client2.start();
            sleep(executePause);
            client3.start();
            sleep(executePause);
            admin.start();
            sleep(executePause);
            client1.getOutput();
            client2.getOutput();
            client3.getOutput();
            admin.getOutput();

            client1.execute("/auth first 12345678");
            sleep(executePause);
            final String client1Answer1 = client1.getOutput().trim();
            if (!client1Answer1.contains("Server: you are authorized successfully!")) {
                return CheckResult.wrong("A registered client can't be authenticated after" +
                        " rebooting a server");
            }

            client2.execute("/auth second 12345678");
            sleep(executePause);
            client2.getOutput();

            admin.execute("/auth admin 12345678");
            sleep(executePause);
            final String adminAnswer1 = admin.getOutput().trim();
            if (!adminAnswer1.contains("Server: you are authorized successfully!")) {
                return CheckResult.wrong("Admin can't log in! Use login \"admin\" and password \"12345678\"");
            }

            admin.execute("/kick admin");
            sleep(executePause);
            final String adminAnswer2 = admin.getOutput().trim();
            if (!adminAnswer2.contains("Server: you can't kick yourself!")) {
                return CheckResult.wrong("Can't find \"Server: you can't kick " +
                        "yourself!\" message after admin's attempt to kick himself");
            }

            admin.execute("/kick first");
            sleep(executePause);
            final String adminAnswer3 = admin.getOutput().trim();
            if (!adminAnswer3.contains("Server: first was kicked!")) {
                return CheckResult.wrong("Can't find \"Server: USER was " +
                        "kicked!\" message after a user \"first\" was kicked by admin");
            }

            admin.execute("/list");
            sleep(executePause);
            final String adminAnswer4 = admin.getOutput().trim();
            if (!adminAnswer4.contains("Server: online: second")) {
                return CheckResult.wrong("Admin received a wrong list of users. " +
                        "Should be \"Server: online: second\"");
            }

            final String client1Answer2 = client1.getOutput().trim();
            if (!client1Answer2.contains("Server: you have been kicked out of the server!")) {
                return CheckResult.wrong("Can't get the message \"Server: you have been " +
                        "kicked out of the server!\" from the \"first\" client perspective");
            }

            client1.execute("I'm not authed");
            sleep(executePause);
            final String client1Answer3 = client1.getOutput().trim();
            if (!client1Answer3.contains("Server: you are not in the chat!")) {
                return CheckResult.wrong("Can't find the message \"Server: you are not in " +
                        "the chat!\" after trying to send a message after being kicked");
            }

            client1.execute("/auth first 12345678");
            sleep(executePause);
            final String client1Answer4 = client1.getOutput().trim();
            if (!client1Answer4.contains("Server: you are banned!")) {
                return CheckResult.wrong("Can't find message \"Server: you are banned!\"");
            }

            client3.execute("/registration first2 12345678");
            sleep(executePause);
            client3.getOutput();

            admin.execute("/grant first2");
            sleep(executePause);
            final String adminAnswer5 = admin.getOutput().trim();
            if (!adminAnswer5.contains("Server: first2 is the new moderator!")) {
                return CheckResult.wrong("Can't find message " +
                        "\"Server: first2 is the new moderator!\" after admin's command \"/grant first2\"");
            }

            final String client3Answer1 = client3.getOutput().trim();
            if (!client3Answer1.contains("Server: you are the new moderator now!")) {
                return CheckResult.wrong("Can't find message \"Server: you are the new " +
                        "moderator now!\" after a user become a moderator");
            }

            admin.execute("/grant first2");
            sleep(executePause);
            final String adminAnswer6 = admin.getOutput().trim();
            if (!adminAnswer6.contains("Server: this user is already a moderator!")) {
                return CheckResult.wrong("Can't find message \"Server: this user is " +
                        "already a moderator!\" after doing the \"/grant\" command on a moderator");
            }

            client3.execute("/kick second");
            sleep(executePause);
            final String client3Answer3 = client3.getOutput().trim();
            if (!client3Answer3.contains("Server: second was kicked!")) {
                return CheckResult.wrong("Can't find message \"Server: second was " +
                        "kicked!\" message after a user was kicked by a moderator");
            }

            final String client2Answer1 = client2.getOutput().trim();
            if (!client2Answer1.contains("Server: you have been kicked out of the server!")) {
                return CheckResult.wrong("Can't find message \"Server: you have been " +
                        "kicked out of the server!\" after a successful kick of a user");
            }

            admin.execute("/list");
            sleep(executePause);
            final String adminAnswer8 = admin.getOutput().trim();
            if (!adminAnswer8.contains("Server: online: first2")) {
                return CheckResult.wrong("Admin received a wrong list of users. Should be \"Server: online: first2\"");
            }

            admin.execute("/kick first2");
            sleep(executePause);
            final String adminAnswer9 = admin.getOutput().trim();
            if (!adminAnswer9.contains("Server: first2 was kicked!")) {
                return CheckResult.wrong("It looks like an admin can't kick a moderator, but should");
            }

            final String client3Answer6 = client3.getOutput().trim();
            if (!client3Answer6.contains("Server: you have been kicked out of the server!")) {
                return CheckResult.wrong("It is look like an admin can't kick a moderator");
            }

            admin.execute("/list");
            sleep(executePause);
            final String adminAnswer10 = admin.getOutput().trim();
            if (!adminAnswer10.contains("Server: no one online")) {
                return CheckResult.wrong("Admin received a wrong list of users. Should be \"Server: no one online\"");
            }

            client1.execute("/exit");
            sleep(executePause);
            client2.execute("/exit");
            sleep(executePause);
            client3.execute("/exit");
            sleep(executePause);
            admin.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @DynamicTestingMethod
        CheckResult test4_revoke() {
            final TestedProgram server = new TestedProgram("chat.server");
            final TestedProgram moderator = new TestedProgram("chat.client");
            final TestedProgram client2 = new TestedProgram("chat.client");
            final TestedProgram admin = new TestedProgram("chat.client");
            moderator.setReturnOutputAfterExecution(false);
            client2.setReturnOutputAfterExecution(false);
            admin.setReturnOutputAfterExecution(false);
            server.startInBackground();
            sleep(executePause);
            moderator.start();
            sleep(executePause);
            client2.start();
            sleep(executePause);
            admin.start();
            sleep(executePause);
            moderator.execute("/registration moderator 12345678");
            sleep(executePause);
            client2.execute("/registration 999 12345678");
            sleep(executePause);
            admin.execute("/auth admin 12345678");
            sleep(executePause);
            admin.execute("/grant moderator");
            sleep(executePause);
            moderator.getOutput();
            client2.getOutput();
            admin.getOutput();

            client2.execute("/revoke admin");
            sleep(executePause);
            final String client2Answer1 = client2.getOutput().trim();
            if (!client2Answer1.equals("Server: you are not an admin!")) {
                return CheckResult.wrong("Can't find message \"Server: you are not an admin!\" " +
                        "after using the \"/revoke\" command by someone who is not an admin");
            }

            moderator.execute("/revoke 999");
            sleep(executePause);
            final String moderatorAnswer1 = moderator.getOutput().trim();
            if (!moderatorAnswer1.equals("Server: you are not an admin!")) {
                return CheckResult.wrong("Can't find message \"Server: you are not an admin!\" " +
                        "after using the \"/revoke\" command by someone who is not an admin");
            }

            admin.execute("/revoke moderator");
            sleep(executePause);
            final String adminAnswer1 = admin.getOutput().trim();
            if (!adminAnswer1.equals("Server: moderator is no longer a moderator!")) {
                return CheckResult.wrong("Can't find message \"Server: USER is no longer" +
                        " a moderator!\" after using the \"/revoke\" command by an admin");
            }

            final String moderatorAnswer2 = moderator.getOutput().trim();
            if (!moderatorAnswer2.equals("Server: you are no longer a moderator!")) {
                return CheckResult.wrong("Can't get the message \"Server: you are no longer" +
                        " a moderator\" after using the \"/revoke\" command by an admin");
            }

            moderator.execute("/kick 999");
            sleep(executePause);
            final String moderatorAnswer3 = moderator.getOutput().trim();
            if (!moderatorAnswer3.equals("Server: you are not a moderator or an admin!")) {
                return CheckResult.wrong("Can't find message " +
                        "\"Server: you are not a moderator or an admin!\" " +
                        "after using the \"/kick\" command by someone who is not an admin or a moderator");
            }

            client2.execute("/exit");
            sleep(executePause);
            moderator.execute("/exit");
            sleep(executePause);
            admin.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @DynamicTestingMethod
        CheckResult test5_statsAndUnread() {
            final TestedProgram server = new TestedProgram("chat.server");
            final TestedProgram client1 = new TestedProgram("chat.client");
            final TestedProgram client2 = new TestedProgram("chat.client");
            final TestedProgram admin = new TestedProgram("chat.client");
            client1.setReturnOutputAfterExecution(false);
            client2.setReturnOutputAfterExecution(false);
            server.startInBackground();
            sleep(executePause);
            client1.start();
            sleep(executePause);
            client2.start();
            sleep(executePause);
            admin.start();
            sleep(executePause);
            client1.execute("/registration client1 12345678");
            sleep(executePause);
            client2.execute("/registration client2 12345678");
            sleep(executePause);
            admin.execute("/auth admin 12345678");
            sleep(executePause);
            client1.getOutput();
            client2.getOutput();
            admin.getOutput();

            admin.execute("/chat client2");
            sleep(executePause);

            client1.execute("/chat client2");
            sleep(executePause);
            client1.execute("1");
            sleep(executePause);
            client1.execute("2");
            sleep(executePause);
            client1.execute("3");
            sleep(executePause);

            admin.execute("/chat client2");
            sleep(executePause);
            admin.execute("1");
            sleep(executePause);
            admin.execute("2");
            sleep(executePause);
            admin.execute("3");
            sleep(executePause);

            client2.execute("/unread");
            sleep(executePause);
            final String client2Answer1 = client2.getOutput().trim();
            if (!client2Answer1.contains("Server: unread from: admin client1")) {
                return CheckResult.wrong("List of unread messages is not correct");
            }

            admin.execute("/unread");
            sleep(executePause);
            final String adminAnswer1 = admin.getOutput().trim();
            if (!adminAnswer1.contains("Server: no one unread")) {
                return CheckResult.wrong("List of unread messages is not correct");
            }

            client2.execute("/chat admin");
            sleep(executePause);
            client2.execute("1");
            sleep(executePause);
            client2.execute("1");
            sleep(executePause);
            client2.execute("1");
            sleep(executePause);

            admin.execute("/chat client2");
            sleep(executePause);

            admin.getOutput();
            admin.execute("/stats");
            sleep(executePause);
            final String adminAnswer2 = admin.getOutput().trim();
            if (!adminAnswer2.equals(
                    "Server:\n" +
                            "Statistics with client2:\n" +
                            "Total messages: 6\n" +
                            "Messages from admin: 3\n" +
                            "Messages from client2: 3"
            )) {
                return CheckResult.wrong("Stats information is not correct");
            }


            admin.execute("1");
            sleep(executePause);

            client2.getOutput();
            client2.execute("/stats");
            sleep(executePause);
            final String client2Answer = client2.getOutput().trim();
            System.out.println(adminAnswer2);
            if (!client2Answer.equals(
                    "Server:\n" +
                            "Statistics with admin:\n" +
                            "Total messages: 7\n" +
                            "Messages from client2: 3\n" +
                            "Messages from admin: 4"
            )) {
                return CheckResult.wrong("Stats information is not correct");
            }

            client1.execute("/exit");
            sleep(executePause);
            client2.execute("/exit");
            sleep(executePause);
            admin.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @DynamicTestingMethod
        CheckResult test6_history100and250() {
            final TestedProgram server = new TestedProgram("chat.server");
            final TestedProgram client3 = new TestedProgram("chat.client");
            final TestedProgram client4 = new TestedProgram("chat.client");
            client3.setReturnOutputAfterExecution(false);
            client4.setReturnOutputAfterExecution(false);
            server.startInBackground();
            sleep(executePause);
            client3.start();
            sleep(executePause);
            client4.start();
            sleep(executePause);
            client3.execute("/registration client3 12345678");
            sleep(executePause);
            client4.execute("/registration client4 12345678");
            sleep(executePause);
            client3.getOutput();
            client4.getOutput();

            client3.execute("/chat client4");
            sleep(executePause);

            for (int i = 1; i <= 50; i++) {
                client3.execute("" + i);
                sleep(executePause);
            }

            client4.execute("/chat client3");
            sleep(executePause);

            final String client4Answer1 = client4.getOutput().trim();
            if (!client4Answer1.equals(
                    "(new) client3: 26\n" +
                            "(new) client3: 27\n" +
                            "(new) client3: 28\n" +
                            "(new) client3: 29\n" +
                            "(new) client3: 30\n" +
                            "(new) client3: 31\n" +
                            "(new) client3: 32\n" +
                            "(new) client3: 33\n" +
                            "(new) client3: 34\n" +
                            "(new) client3: 35\n" +
                            "(new) client3: 36\n" +
                            "(new) client3: 37\n" +
                            "(new) client3: 38\n" +
                            "(new) client3: 39\n" +
                            "(new) client3: 40\n" +
                            "(new) client3: 41\n" +
                            "(new) client3: 42\n" +
                            "(new) client3: 43\n" +
                            "(new) client3: 44\n" +
                            "(new) client3: 45\n" +
                            "(new) client3: 46\n" +
                            "(new) client3: 47\n" +
                            "(new) client3: 48\n" +
                            "(new) client3: 49\n" +
                            "(new) client3: 50"
            )) {
                return CheckResult.wrong("A user get wrong messages. Maybe, your server " +
                        "sent more than 25 unread messages? \"client3\" should " +
                        "receive messages from 26 to 50 inclusive " +
                        "(exactly 25 messages).");
            }


            client4.execute("/history test");
            sleep(executePause);
            final String client4Answer2 = client4.getOutput().trim();
            if (!client4Answer2.contains("Server: test is not a number!")) {
                return CheckResult.wrong("Can't get the message \"Server: test is not a number!\"");
            }

            client4.execute("/history 35");
            sleep(executePause);
            final String client4Answer3 = client4.getOutput().trim();
            if (!client4Answer3.equals(
                    "Server:\n" +
                            "client3: 16\n" +
                            "client3: 17\n" +
                            "client3: 18\n" +
                            "client3: 19\n" +
                            "client3: 20\n" +
                            "client3: 21\n" +
                            "client3: 22\n" +
                            "client3: 23\n" +
                            "client3: 24\n" +
                            "client3: 25\n" +
                            "client3: 26\n" +
                            "client3: 27\n" +
                            "client3: 28\n" +
                            "client3: 29\n" +
                            "client3: 30\n" +
                            "client3: 31\n" +
                            "client3: 32\n" +
                            "client3: 33\n" +
                            "client3: 34\n" +
                            "client3: 35\n" +
                            "client3: 36\n" +
                            "client3: 37\n" +
                            "client3: 38\n" +
                            "client3: 39\n" +
                            "client3: 40"
            )) {
                return CheckResult.wrong("A user received wrong messages after the " +
                        "\"/history X\". Maybe your server sent more than 25 messages?\n" +
                        "For the command \"/history 35\" server should sent from 35-th to 11-th messages inclusive" +
                        "from the end of the conversation.\n" +
                        "Which is from \"client3: 16\" to \"client3: 40\".");
            }

            client4.execute("/exit");
            sleep(executePause);
            client3.execute("/exit");
            sleep(executePause);

            return CheckResult.correct();
        }

        @BeforeClass
        public static void createTempDatabaseFile() throws IOException {

            Path userDbFile = Paths.get(userDBFileName);
            Path tempUserDbFile = Paths.get(tempUserDBFileName);
            Path messageDbFile = Paths.get(messageDBFileName);
            Path tempMessageDbFile = Paths.get(tempMessageDBFileName);

            if (!userDbFile.toFile().exists())
                return;

            try {
                Files.deleteIfExists(tempUserDbFile);
                Files.move(userDbFile, tempUserDbFile);
                Files.deleteIfExists(tempMessageDbFile);
                Files.move(messageDbFile, tempMessageDbFile);
            } catch (Exception ignored) {}
        }

        @AfterClass
        public static void deleteTempDatabaseFile() throws IOException {

            Path userDbFile = Paths.get(userDBFileName);
            Path tempUserDbFile = Paths.get(tempUserDBFileName);
            Path messageDbFile = Paths.get(messageDBFileName);
            Path tempMessageDbFile = Paths.get(tempMessageDBFileName);

            if (!tempUserDbFile.toFile().exists())
                return;

            try {
                Files.deleteIfExists(userDbFile);
                Files.move(tempUserDbFile, userDbFile);
                Files.deleteIfExists(messageDbFile);
                Files.move(tempMessageDbFile, messageDbFile);
            } catch (Exception ignored) {}
        }

    }
  learner_created: false
- name: src/chat/server/controller/Controller.java
  visible: true
  text: |
    package chat.server.controller;

    import chat.server.command.Command;

    public class Controller {

        private Command command;

        public void executeCommand() {
            if (command != null) {
                command.execute();
            }
        }

        public void setCommand(Command command) {
            this.command = command;
        }

    }
  learner_created: true
- name: src/chat/server/command/Commands.java
  visible: true
  text: |
    package chat.server.command;

    import java.util.EnumSet;
    import java.util.Set;

    public enum Commands {
        REGISTRATION("/registration"),
        AUTHENTICATION("/auth"),
        LIST("/list"),
        CHAT("/chat"),
        EXIT("/exit");

        private String text;

        Commands(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }

        public static Commands fromText(String text) {
            for (Commands c : Commands.values()) {
                if (c.getText().equals(text)) {
                    return c;
                }
            }
            throw new IllegalArgumentException("No command found for " + text);
        }

        public static boolean isCommand(String token) {
            if (token == null) {
                return false;
            }
            for (Commands command : Commands.values()) {
                if (token.startsWith(command.getText())) {
                    return true;
                }
            }
            return false;
        }

        public static Set<Commands> getAuthenticationRegistrationCommands() {
            return EnumSet.of(REGISTRATION, AUTHENTICATION);
        }
    }
  learner_created: true
- name: src/chat/server/utils/HashingUtils.java
  visible: true
  text: |
    package chat.server.utils;

    import java.nio.charset.StandardCharsets;
    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;

    public final class HashingUtils {

        private static final String HASH_ALGORITHM = "encryption_algorithm";

        private static MessageDigest MESSAGE_DIGEST = null;

        static {
            try {
                MESSAGE_DIGEST = MessageDigest.getInstance(PropertyHolder.properties.getProperty(HASH_ALGORITHM));
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
                System.exit(1);
            }
        }

        public static byte[] hash(String hash) {
            return MESSAGE_DIGEST.digest(hash.getBytes(StandardCharsets.UTF_8));
        }

    }
  learner_created: true
- name: src/chat/server/user/UserService.java
  visible: true
  text: |
    package chat.server.user;

    import chat.server.utils.PropertyHolder;

    import java.io.*;
    import java.util.HashSet;
    import java.util.Set;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReadWriteLock;
    import java.util.concurrent.locks.ReentrantReadWriteLock;

    public class UserService {

        private final File database = new File(PropertyHolder.getProperty("user_database"));

        private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        private final Lock readLock = readWriteLock.readLock();
        private final Lock writeLock = readWriteLock.writeLock();
        private Set<User> users = new HashSet<>();

        public UserService() {
            try {
                initDatabase();
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
                System.exit(1);
            }
        }

        public boolean usernameExists(String username) {
            if (username == null) {
                return false;
            }

            try {
                readLock.lock();
                return users.stream()
                        .map(User::getName)
                        .anyMatch(username::equals);
            } finally {
                readLock.unlock();
            }
        }

        public boolean authenticateUser(User user) {
            if (user == null) {
                return false;
            }

            try {
                readLock.lock();
                return users.stream()
                        .anyMatch(user::equals);
            } finally {
                readLock.unlock();
            }
        }

        public void addUser(User user) {
            try {
                writeLock.lock();
                users.add(user);
                writeToDatabase();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
            }
        }

        private void initDatabase() throws IOException, ClassNotFoundException {
            if (database.exists()) {
                try (FileInputStream fis = new FileInputStream(database);
                     ObjectInputStream ois = new ObjectInputStream(fis)) {
                    writeLock.lock();
                    users.clear();
                    while (true) {
                        try {
                            User user = (User) ois.readObject();
                            users.add(user);
                        } catch (EOFException e) {
                            // reading until everthing is in
                            break;
                        }
                    }

                } finally {
                    writeLock.unlock();
                }
            }
        }

        private synchronized void writeToDatabase() throws IOException {
            try (FileOutputStream fos = new FileOutputStream(database.toString());
                 ObjectOutputStream oos = new ObjectOutputStream(fos)) {
                for (User user : users) {
                    oos.writeObject(user);
                }
            }
        }
    }
  learner_created: true
- name: src/chat/server/command/implementation/ChatCommand.java
  visible: true
  text: |
    package chat.server.command.implementation;

    import chat.server.command.Command;
    import chat.server.errors.ErrorResponses;
    import chat.server.utils.ClientHandler;
    import chat.server.utils.SocketHandler;

    import java.util.Arrays;
    import java.util.Optional;
    import java.util.stream.Collectors;

    public class ChatCommand extends SocketHandler implements Command {

        private ClientHandler clientHandler;

        public ChatCommand(ClientHandler clientHandler) {
            socket = clientHandler.getSocket();
            this.clientHandler = clientHandler;
        }

        @Override
        public void execute() {
            String currentMessage = clientHandler.getCurrentMessage();
            String username = Arrays.stream(currentMessage.split("\\s"))
                    .skip(1)
                    .collect(Collectors.joining(" "));

            Optional<ClientHandler> potentialClient = clientHandler.getClientsOnline().stream()
                    .filter(client -> username.equals(client.getUsername()))
                    .findAny();

            if (potentialClient.isPresent()) {
                clientHandler.setAddressee(potentialClient.get());
                clientHandler.getMessageService()
                        .getLastMessages(potentialClient.get().getUser(), clientHandler.getUser())
                        .forEach(message -> {
                            clientHandler.writeMessage(message.toString());
                            message.setNew(false);
                        });
            } else {
                writeMessage(ErrorResponses.USER_NOT_ONLINE.getText());
            }
        }
    }
  learner_created: true
- name: src/chat/client/utils/PropertyHolder.java
  visible: true
  text: |
    package chat.client.utils;

    import java.io.FileReader;
    import java.io.IOException;
    import java.util.Properties;

    public class PropertyHolder {

        private static final String PATH = "/Users/konradvonkirchbach/IdeaProjects/Online Chat/Online Chat/task/src/chat/client/resources/client_properties.properties";
        public static Properties properties;

        static {
            try (FileReader reader = new FileReader(PATH)) {
                properties = new Properties();
                properties.load(reader);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
  learner_created: true
- name: src/chat/server/user/User.java
  visible: true
  text: |
    package chat.server.user;

    import java.io.Serializable;
    import java.util.Arrays;

    public class User implements Serializable {

        private String name;

        private byte[] hashedPassword;

        public User(String name, byte[] hashedPassword) {
            this.name = name;
            this.hashedPassword = hashedPassword;
        }

        public String getName() {
            return name;
        }

        public byte[] getHashedPassword() {
            return hashedPassword;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            User user = (User) o;

            if (name != null ? !name.equals(user.name) : user.name != null) return false;
            return Arrays.equals(hashedPassword, user.hashedPassword);
        }

        @Override
        public int hashCode() {
            int result = name != null ? name.hashCode() : 0;
            result = 31 * result + Arrays.hashCode(hashedPassword);
            return result;
        }

        @Override
        public String toString() {
            return String.format("User %s, hashpw %s", name, Arrays.toString(hashedPassword));
        }
    }
  learner_created: true
- name: src/chat/server/message/Message.java
  visible: true
  text: |
    package chat.server.message;

    import chat.server.user.User;

    import java.io.Serializable;

    public class Message implements Serializable {

        private String message;

        private boolean isNew;

        private User sender;

        private User receiver;

        public Message(String message, boolean isNew, User sender, User receiver) {
            this.message = message;
            this.isNew = isNew;
            this.sender = sender;
            this.receiver = receiver;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public boolean isNew() {
            return isNew;
        }

        public void setNew(boolean aNew) {
            isNew = aNew;
        }

        public User getSender() {
            return sender;
        }

        public void setSender(User sender) {
            this.sender = sender;
        }

        public User getReceiver() {
            return receiver;
        }

        public void setReceiver(User receiver) {
            this.receiver = receiver;
        }

        public boolean isMessageOfChat(User sender, User receiver) {
            if (getReceiver() == null && getSender() == null) {
                return sender == null && receiver == null;
            }

            if (getSender() == null) {
                return sender == null && getReceiver().equals(receiver);
            }

            if (getReceiver() == null) {
                return receiver == null && getSender().equals(sender);
            }

            return (getSender().equals(sender) || getReceiver().equals(sender))
                    &&
                    (getSender().equals(receiver) || getReceiver().equals(receiver));
        }

        public String getSimpleForm() {
            return String.format("%s: %s", sender.getName(), message);
        }

        @Override
        public String toString() {
            if (isNew) {
                return String.format("(new) %s: %s", sender.getName(), message);
            } else {
                return String.format("%s: %s", sender.getName(), message);
            }
        }
    }
  learner_created: true
- name: src/chat/server/message/MessageService.java
  visible: true
  text: |
    package chat.server.message;

    import chat.server.user.User;
    import chat.server.utils.PropertyHolder;

    import java.io.*;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReadWriteLock;
    import java.util.concurrent.locks.ReentrantReadWriteLock;
    import java.util.stream.Collectors;

    public class MessageService {

        private final File database = new File(PropertyHolder.getProperty("message_database"));
        private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        private final Lock readLock = readWriteLock.readLock();
        private final Lock writeLock = readWriteLock.writeLock();

        private List<Message> messages = new ArrayList<>();

        public MessageService() {
            try {
                initDatabase();
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
                System.exit(1);
            }
        }

        public void addMessage(Message message) {
            try {
                writeLock.lock();
                messages.add(message);
                writeToDatabase();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
            }
        }

        public List<Message> getLastMessages(User sender, User receiver) {
            try {
                readLock.lock();
                List<Message> chat = messages.stream()
                        .filter(message -> message.isMessageOfChat(sender, receiver))
                        .collect(Collectors.toList());
                if (chat.size() > 10) {
                    return chat.subList(chat.size() - 10, chat.size());
                } else {
                    return chat;
                }
            } finally {
                readLock.unlock();
            }
        }

        private void initDatabase() throws IOException, ClassNotFoundException {
            if (database.exists()) {
                try (FileInputStream fis = new FileInputStream(database);
                     ObjectInputStream ois = new ObjectInputStream(fis)) {
                    writeLock.lock();
                    messages.clear();
                    while (true) {
                        try {
                            Message message = (Message) ois.readObject();
                            messages.add(message);
                        } catch (EOFException e) {
                            // End of file
                            break;
                        }
                    }
                } finally {
                    writeLock.unlock();
                }
            }
        }

        private synchronized void writeToDatabase() throws IOException {
            try (FileOutputStream fos = new FileOutputStream(database.toString());
                 ObjectOutputStream oos = new ObjectOutputStream(fos)) {
                for (Message message : messages) {
                    oos.writeObject(message);
                }
            }
        }

    }
  learner_created: true
- name: src/chat/server/command/implementation/ListCommand.java
  visible: true
  text: |
    package chat.server.command.implementation;

    import chat.server.command.Command;
    import chat.server.utils.ClientHandler;
    import chat.server.utils.SocketHandler;

    import java.util.List;
    import java.util.stream.Collectors;

    public class ListCommand extends SocketHandler implements Command {

        private ClientHandler clientHandler;

        public ListCommand(ClientHandler clientHandler) {
            socket = clientHandler.getSocket();
            this.clientHandler = clientHandler;
        }

        @Override
        public void execute() {
            List<ClientHandler> clientsOnline = clientHandler.getClientsOnline();
            if (clientsOnline.size() == 1 && clientsOnline.get(0) == clientHandler) {
                writeMessage("Server: no one online");
            } else {
                String usernames = clientsOnline.stream()
                        .filter(ch -> !ch.equals(clientHandler))
                        .map(ClientHandler::getUsername)
                        .collect(Collectors.joining(" "));
                writeMessage("Server: online: " + usernames);
            }
        }
    }
  learner_created: true
- name: src/chat/server/utils/SocketHandler.java
  visible: true
  text: |
    package chat.server.utils;

    import java.io.DataInputStream;
    import java.io.DataOutputStream;
    import java.io.IOException;
    import java.net.Socket;
    import java.util.Optional;

    public abstract class SocketHandler {

        protected Socket socket;

        protected Optional<String> readMessage() {
            if (socket == null) {
                System.err.println("Socket not set");
                return Optional.empty();
            }

            try {
                DataInputStream is = new DataInputStream(socket.getInputStream());
                return Optional.of(is.readUTF());
            } catch (IOException e) {
                e.printStackTrace();
            }
            return Optional.empty();
        }

        protected void writeMessage(String message) {
            if (socket == null) {
                System.err.println("Socket not set");
                return;
            }

            try {
                DataOutputStream os = new DataOutputStream(socket.getOutputStream());
                os.writeUTF(message);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
  learner_created: true
- name: src/chat/server/utils/ClientHandler.java
  visible: true
  text: |
    package chat.server.utils;

    import chat.server.command.Command;
    import chat.server.command.Commands;
    import chat.server.command.implementation.ChatCommand;
    import chat.server.command.implementation.ExitCommand;
    import chat.server.command.implementation.ListCommand;
    import chat.server.command.implementation.RegistrationAuthorizationCommand;
    import chat.server.controller.Controller;
    import chat.server.errors.ErrorResponses;
    import chat.server.message.Message;
    import chat.server.message.MessageService;
    import chat.server.user.User;
    import chat.server.user.UserService;

    import java.io.DataInputStream;
    import java.io.DataOutputStream;
    import java.io.IOException;
    import java.net.Socket;
    import java.util.List;
    import java.util.Optional;
    import java.util.logging.Logger;

    public class ClientHandler extends Thread {

        private Logger logger = Logger.getLogger(ClientHandler.currentThread().getName());

        private Socket socket;
        private DataInputStream is;
        private DataOutputStream os;

        private User user;

        private MessageService messageService;

        private UserService userService;

        private List<ClientHandler> clientsOnline;

        private Controller controller = new Controller();

        private ClientHandler addressee;

        private String currentMessage;

        public ClientHandler(Socket socket,
                             MessageService messageService,
                             UserService userService,
                             List<ClientHandler> clients) {
            this.socket = socket;
            this.messageService = messageService;
            this.userService = userService;
            this.clientsOnline = clients;
            try {
                this.is = new DataInputStream(socket.getInputStream());
                this.os = new DataOutputStream(socket.getOutputStream());
            } catch (IOException e) {
                closeSocket();
            }
        }

        @Override
        public void run()  {
            if (socket == null) {
                return;
            }

            // registration or authentication
            RegistrationAuthorizationCommand rac = new RegistrationAuthorizationCommand(this);
            controller.setCommand(rac);
            controller.executeCommand();
            if (!rac.isProcessComplete()) {
                closeSocket();
            }

            // continuous chatting to group or people
            while (socket != null && socket.isConnected()) {
                Optional<String> optionalMessage = readMessage();
                if (optionalMessage.isPresent()) {
                    currentMessage = optionalMessage.get();
                    // perform the command
                    if (Commands.isCommand(currentMessage)) {
                        Command command = buildCommand(currentMessage);
                        controller.setCommand(command);
                        controller.executeCommand();
                    } // client did not choose an addresse
                    else if (addressee == null) {
                        writeMessage(ErrorResponses.NO_ADDRESSE.getText());
                    } // send to addresse
                    else {
                        boolean isOnline = getClientsOnline().contains(addressee);
                        Message message = new Message(currentMessage,
                                isOnline,
                                user,
                                addressee.user);

                        writeMessage(message.getSimpleForm());

                        if (isOnline && addressee.getAddressee() == this) {
                            message.setNew(false);
                            addressee.writeMessage(message.toString());
                        }

                        messageService.addMessage(message);
                    }
                }
            }
            closeSocket();
            logger.info(user.getName() + " signed off");
        }

        public final UserService getUserService() {
            return userService;
        }

        public final MessageService getMessageService() {
            return messageService;
        }

        public void setUser(User user) {
            this.user = user;
        }

        public User getUser() {
            return user;
        }

        public String getUsername() {
            return user.getName();
        }

        public final Socket getSocket() {
            return socket;
        }

        public String getCurrentMessage() {
            return currentMessage;
        }

        public void setAddressee(ClientHandler addressee) {
            this.addressee = addressee;
        }

        public ClientHandler getAddressee() {
            return addressee;
        }

        public void closeSocket() {
            if (socket != null) {
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            socket = null;
            removeClient();
        }

        public void addClient() {
            logger.info(user.getName() + " added to online clients");
            getClientsOnline().add(this);
        }

        public void writeMessage(String message) {
            synchronized (this) {
                try {
                    os.writeUTF(message);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        private Optional<String> readMessage() {
            try {
                return Optional.of(is.readUTF());
            } catch (IOException e) {
                e.printStackTrace();
            }
            return Optional.empty();
        }

        private void removeClient() {
            logger.info(user.getName() + " removed from online clients");
            getClientsOnline().remove(this);
        }

        public synchronized List<ClientHandler> getClientsOnline() {
            return clientsOnline;
        }

        private Command buildCommand(String message) {
            Commands command = Commands.fromText(message.split("\\s+")[0]);
            switch (command) {
                case REGISTRATION:
                case AUTHENTICATION: return new RegistrationAuthorizationCommand(this);
                case LIST: return new ListCommand(this);
                case CHAT: return new ChatCommand(this);
                case EXIT: return new ExitCommand(this);
                default: throw new IllegalArgumentException("No command found for " + command.getText());
            }
        }
    }
  learner_created: true
- name: src/chat/server/command/implementation/RegistrationAuthorizationCommand.java
  visible: true
  text: |
    package chat.server.command.implementation;

    import chat.server.command.Command;
    import chat.server.command.Commands;
    import chat.server.errors.ErrorResponses;
    import chat.server.user.User;
    import chat.server.user.UserService;
    import chat.server.utils.ClientHandler;
    import chat.server.utils.HashingUtils;
    import chat.server.utils.SocketHandler;

    import java.util.Optional;

    public class RegistrationAuthorizationCommand extends SocketHandler implements Command {

        private UserService userService;

        private Commands command;

        private String username;

        private String password;

        private boolean processComplete = false;

        private User user;

        private ClientHandler clientHandler;

        public RegistrationAuthorizationCommand(ClientHandler clientHandler) {
            this.clientHandler = clientHandler;
            this.userService = clientHandler.getUserService();
            this.socket = clientHandler.getSocket();
        }

        @Override
        public void execute() {
            writeMessage("Server: authorize or register");
            while (!processComplete) {
                readAndAssignUser();
                switch (command) {
                    case REGISTRATION: {
                        registration();
                        break;
                    }
                    case AUTHENTICATION: {
                        authenticate();
                        break;
                    }
                }
            }
            if (processComplete) {
                userService.addUser(user);
                clientHandler.setUser(user);
                clientHandler.addClient();
            }
        }

        public boolean isProcessComplete() {
            return processComplete;
        }

        private void registration() {
            boolean isValid = !usernameExists(username) && passwordIsValid(password);
            while (!isValid) {
                if (usernameExists(username)) {
                    writeMessage(ErrorResponses.LOGIN_TAKEN.getText());
                    readAndAssignUser();
                    continue;
                }

                if (!passwordIsValid(password)) {
                    writeMessage(ErrorResponses.PASSWORD_TOO_SHORT.getText());
                    readAndAssignUser();
                }

                if (command != Commands.REGISTRATION) {
                    return;
                }

                isValid = !usernameExists(username) && passwordIsValid(password);
            }
            user = new User(username, HashingUtils.hash(password));
            writeMessage("Server: you are registered successfully!");
            processComplete = true;
        }

        private boolean passwordIsValid(String password) {
            return password.length() > 7;
        }

        private boolean usernameExists(String username) {
            return userService.usernameExists(username);
        }

        private void authenticate() {
            boolean isAuthenticated = false;
            while (!isAuthenticated) {
                user = new User(username, HashingUtils.hash(password));

                if (!usernameExists(username)) {
                    writeMessage(ErrorResponses.INCORRECT_LOGIN.getText());
                    readAndAssignUser();
                    continue;
                }

                if (!userService.authenticateUser(user)) {
                    writeMessage(ErrorResponses.INCORRECT_PASSWORD.getText());
                    readAndAssignUser();
                    continue;
                }

                if (command != Commands.AUTHENTICATION) {
                    return;
                }

                isAuthenticated = userService.authenticateUser(user);
            }
            writeMessage("Server: you are authorized successfully!");
            processComplete = true;
        }

        private void readAndAssignUser() {
            while (true) {
                Optional<String> optionalMessage = readMessage();
                if (optionalMessage.isPresent()) {
                    String message = optionalMessage.get();
                    String[] tokens = message.split("\\s");
                    if (!Commands.isCommand(message)) {
                        writeMessage(ErrorResponses.NOT_IN_CHAT.getText());
                    } else {
                        command = Commands.fromText(tokens[0]);
                    }
                    if (!Commands.getAuthenticationRegistrationCommands().contains(command)) {
                        if (command == Commands.CHAT) {
                            writeMessage(ErrorResponses.NOT_IN_CHAT.getText());
                        } else {
                            writeMessage(ErrorResponses.INCORRECT_COMMAND.getText());
                        }
                    } else {
                        if (tokens.length > 2) {
                            username = tokens[1];
                            password = tokens[2];
                            break;
                        }
                    }
                }
            }
        }
    }
  learner_created: true
- name: src/chat/client/Client.java
  visible: true
  text: |-
    package chat.client;

    import chat.client.utils.PropertyHolder;

    import java.io.DataInputStream;
    import java.io.DataOutputStream;
    import java.io.IOException;
    import java.net.InetAddress;
    import java.net.Socket;
    import java.net.SocketException;
    import java.util.Scanner;

    public class Client {

        public static void main(String[] args) {
            String ip = (String) PropertyHolder.properties.get("ip_address");
            int port = Integer.valueOf((String) PropertyHolder.properties.get("port"));
            OutputReader or = null;
            InputReader ir = null;
            try (Socket socket = new Socket(InetAddress.getByName(ip), port);
                 DataInputStream is = new DataInputStream(socket.getInputStream());
                 DataOutputStream os = new DataOutputStream(socket.getOutputStream())) {
                ir = new InputReader(is, socket);
                or = new OutputReader(socket, os);
                System.out.println("Client started!");
                ir.start();
                or.start();
                or.join();
            } catch (Exception e) {
                e.printStackTrace();
            }

        }

    }

    class InputReader extends Thread {
        private DataInputStream is;

        private Socket socket;

        public InputReader(DataInputStream is,
                           Socket socket) {
            this.is = is;
            this.socket = socket;
        }

        @Override
        public void run() {
            while (!socket.isClosed()) {
                try {
                    System.out.println(is.readUTF());
                } catch (IOException e) {
                    e.printStackTrace();
                    if (e instanceof SocketException) {
                        break;
                    }
                }
            }
        }
    }

    class OutputReader extends Thread {

        private Socket socket;
        private DataOutputStream os;

        private Scanner scanner = new Scanner(System.in);

        public OutputReader(Socket socket, DataOutputStream os) {
            this.socket = socket;
            this.os = os;
        }

        private void sendMessage(String message) {
            try {
                os.writeUTF(message);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void run() {
            while (socket.isConnected()) {
                if (scanner.hasNextLine()) {
                    String nextLine = scanner.nextLine();
                    sendMessage(nextLine);
                    if ("/exit".equals(nextLine)) {
                        return;
                    }
                }
            }
        }
    }
  learner_created: true
- name: src/chat/server/resources/server_properties.properties
  visible: true
  text: |-
    ip_address=127.0.0.1
    port=23456
    encryption_algorithm=SHA3-256
    run_forever=false
    user_database=usersdb.txt
    message_database=messagedb.txt
  learner_created: true
- name: src/chat/server/command/implementation/ExitCommand.java
  visible: true
  text: |
    package chat.server.command.implementation;

    import chat.server.command.Command;
    import chat.server.utils.ClientHandler;
    import chat.server.utils.SocketHandler;

    public class ExitCommand extends SocketHandler implements Command {

        private ClientHandler clientHandler;

        public ExitCommand(ClientHandler clientHandler) {
            this.clientHandler = clientHandler;
        }

        @Override
        public void execute() {
            clientHandler.closeSocket();
        }
    }
  learner_created: true
- name: src/chat/server/command/Command.java
  visible: true
  text: |
    package chat.server.command;

    public interface Command {
        void execute();
    }
  learner_created: true
- name: src/chat/client/resources/client_properties.properties
  visible: true
  text: |-
    ip_address=127.0.0.1
    port=23456
  learner_created: true
- name: src/chat/server/Server.java
  visible: true
  text: |
    package chat.server;

    import chat.server.message.MessageService;
    import chat.server.user.UserService;
    import chat.server.utils.PropertyHolder;
    import chat.server.utils.ClientHandler;

    import java.io.IOException;
    import java.net.InetAddress;
    import java.net.ServerSocket;
    import java.net.Socket;
    import java.time.Instant;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.CopyOnWriteArrayList;

    public class Server {

        public static void main(String[] args) {
            System.out.println("Server started!");
            String ip = PropertyHolder.properties.getProperty("ip_address");
            int port = Integer.parseInt(PropertyHolder.properties.getProperty("port"));

            MessageService messageService = new MessageService();
            UserService userService = new UserService();
            List<ClientHandler> clients = new ArrayList<>();

            try (ServerSocket serverSocket = new ServerSocket(port, 50, InetAddress.getByName(ip))) {
                Instant deadLine = Instant.now().plusSeconds(10);
                Boolean shouldRunForever = Boolean.getBoolean(PropertyHolder.getProperty("run_forever"));
                serverSocket.setSoTimeout(3_000);
                while (shouldRunForever || Instant.now().isBefore(deadLine)) {
                    try {
                        Socket socket = serverSocket.accept();
                        ClientHandler clientHandler = new ClientHandler(socket,
                                messageService,
                                userService,
                                clients);
                        clientHandler.start();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
  learner_created: true
- name: src/chat/server/user/Roles.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/GrantCommand.java
  visible: true
  learner_created: true
- name: src/chat/server/serverresponses/ErrorResponses.java
  visible: true
  text: |
    package chat.server.errors;

    public enum ErrorResponses {
        INCORRECT_COMMAND("Server: incorrect command!"),
        LOGIN_TAKEN("Server: this login is already taken! Choose another one."),
        PASSWORD_TOO_SHORT("Server: the password is too short!"),
        INCORRECT_LOGIN("Server: incorrect login!"),
        INCORRECT_PASSWORD("Server: incorrect password!"),
        NO_ADDRESSE("Server: use /list command to choose a user to text!"),
        NOT_IN_CHAT("Server: you are not in the chat!"),
        USER_NOT_ONLINE("Server: the user is not online!");
        private String text;

        ErrorResponses(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }
    }
  learner_created: true
- name: src/chat/server/serverresponses/SuccessResponse.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/RevokeCommand.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/KickCommand.java
  visible: true
  learner_created: true
- name: messagedb.txt
  visible: true
  learner_created: true
- name: usersdb.txt
  visible: true
  learner_created: true
- name: src/chat/server/dtos/ClientsOnline.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/UnreadCommand.java
  visible: true
  learner_created: true
- name: src/chat/server/dtos/StatisticDto.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/StatsCommand.java
  visible: true
  learner_created: true
- name: src/chat/server/command/implementation/HistoryCommand.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/5412#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Sat, 13 Aug 2022 11:08:49 UTC
record: -1
